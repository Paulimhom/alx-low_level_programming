C - Static libraries
What is the format of a static library?
The format of a static library is an archive. A static library is a collection of object files that are combined into a single file in archive format. This allows multiple object files to be treated as a single entity when linking with other object files or libraries to create an executable or shared library. It is a file containing multiple object files that have been bundled together using the ar command. The archive file typically has a ".a" extension and consists of a table of contents (or index) followed by the object files themselves. The object files within the archive are stored in a platform-specific object file format, such as the COFF format on Windows or the ELF format on Linux and other Unix-like operating systems. When a program is linked against a static library, the linker extracts the necessary object files from the library and combines them with the object files generated by compiling the program to produce a single executable binary.

What command(s) can be used to list the symbols stored in a static library?
The nm command can be used to list the symbols stored in a static library. nm lists the symbols from object files specified on its command line. When given an archive (static library), nm lists the symbols in each object file in the archive. The nm command can be used to list the symbols stored in a static library.

The ar command is used to create, modify, and extract files from static libraries.

The ld command is used to link object files and libraries to create an executable or shared object file.

The ranlib command is used to generate an index for the contents of an archive library, which speeds up symbol lookup when the library is used.

The other commands you mentioned (ar, ld, and ranlib) are also related to static libraries but do not list their symbols.

What command is used to create a static library from object files?
The ar command is used to create a static library from object files. ar stands for “archiver” and it is used to create, modify and extract from archives (static libraries). To create a static library from object files using ar, you can use the following command:

ar rcs libname.a file1.o file2.o file3.o
This command creates a static library named libname.a from the object files file1.o, file2.o, and file3.o. The options r, c, and s tell ar to insert the object files into the archive (replacing any existing members with the same name), create the archive if it doesn’t exist, and generate an index for faster linking respectively. The ar command is part of the GNU Binutils package and is typically used in conjunction with the gcc compiler. The basic syntax for creating a static library with ar is as follows:

ar rcs libfoo.a foo1.o foo2.o foo3.o
This command creates a static library called "libfoo.a" from the object files "foo1.o", "foo2.o", and "foo3.o". The r option specifies that the object files should be added to the archive or replaced if they already exist, the c option creates the archive if it doesn't already exist, and the s option creates an index for the archive to speed up symbol lookup.

What is the point of using ranlib?
The point of using ranlib is for indexing an archive. ranlib generates an index to the contents of an archive and stores it in the archive. The index lists each symbol defined by a member of an archive that is a relocatable object file. This index speeds up linking to the library and allows routines in the library to call each other without regard to their placement in the archive. Many systems automatically run ranlib when a library is created or modified, so it may not always be necessary to run it explicitly.

When an archive is created or modified with the ar command, it does not contain an index of the symbols contained within it. This can make it slow to search for symbols when linking against the library. The ranlib command generates an index of the symbols in the archive, which can speed up symbol lookup when the library is used.

The basic syntax for using ranlib is as follows:

ranlib libfoo.a
This command generates an index for the archive library "libfoo.a". The index is stored as a special object file within the archive, which the linker can use to quickly find symbols within the library.

What is a library and why should I use them?
If you have some experience with C language, might you see header files like stdio.h, stdlib.h, string.h, ctype.h, etc. These are commonly used libraries in C. Sometimes you create a function and you need to implement this function in other scripts but copy and paste the code is the worst way to implement it. Probably, C libraries are an efficient and good practice to call functions inside the program. Ok, let's talk a little bit about libraries in C.

Libraries in programming languages as C allow creating reusable collections of precompiled routines code. The program could access and use these frequently functions stored in the library.

The reason that is recommendable to use libraries is that they are a recursively way to load different routines that are necessary for the program regardless of repeat code lines. Libraries allow you to create one file that your program can use either during compile time (static) or run time (dynamic) to locate and use the set of functions you included in the library file.

Differences, advantages/disadvantages between Static and Dynamic Libraries
At the moment to compile the program, the linker uses the libraries listed inside the main scrip to linking whole the routines involved in the and necessaries to run correctly. There are 2 types of libraries: static or dynamic.

Static libraries: Each routine listed in the library is linked with the rest files by the compiler, indifferently if some routine will not be used when the program is running. However, you can carry the program from other devices and it continues running well.

Dynamic libraries: Unlike Static libraries, the routines listed in the dynamic library aren't linked with the rest files by the compiler, it only links the address memory and when the program is running it could use the function that it needs. But, if you move the program to another device, it will not have access to those routines listed inside the library.

Frequently, Static libraries have a bigger size than Dynamic libraries.

How to create a Static Library?
Create a header file and list all the functions (routines) for the library, for example, the static library containing all the functions listed below:

int _putchar(char c);
int _islower(int c);
int _isalpha(int c);
int _abs(int n);
int _isupper(int c);
int _isdigit(int c);
int _strlen(char *s);
void _puts(char *s);
char *_strcpy(char *dest, char *src);
int _atoi(char *s);
char *_strcat(char *dest, char *src);
char *_strncat(char *dest, char *src, int n);
char *_strncpy(char *dest, char *src, int n);
int _strcmp(char *s1, char *s2);
char *_memset(char *s, char b, unsigned int n);
char *_memcpy(char *dest, char *src, unsigned int n);
char *_strchr(char *s, char c);
unsigned int _strspn(char *s, char *accept);
char *_strpbrk(char *s, char *accept);
char *_strstr(char *haystack, char *needle);
To compile each function listed in the header file, using gcc compiler:

gcc -Wall -pedantic -Werror -Wextra -c *.c
Next step is to create the object files for each *.c file and create the static library, like this:

ar -rc libstatic1.a *.o
Well done! a static library called "libstatic1.a" was created.

How to create a Dynamic Library?
Dynamic libraries creation is easier than Static libraries because there's no need to create object files. You should make Position Independent Code -PIC- and specify the library name finished with .so extension:

gcc -fPIC *.c -shared -o dynamic_library_name.so
How to use a Static or Dynamic Library?
Now, when you need anyone library created above, you just add the library to your main.c file at the moment to compile, and you will obtain an executable file called "the_program":

gcc main.c -L. -library_name -o the_program
Here is a script that you can use to create a static library called liball.a from all the .c files in the current directory:

#!/bin/bash

Compile all .c files into .o files
gcc -c *.c
Create a static library from all .o files
ar rcs liball.a *.o
To use this script, save it to a file named create_static_lib.sh and make it executable by running the command chmod +x create_static_lib.sh. Then you can run the script by typing ./create_static_lib.sh.

This will compile all .c files in the current directory into object files and then create a static library named liball.a from those object files.

Here’s an explanation of each command:

gcc -c *.c: This command uses the gcc compiler to compile all .c files in the current directory into object files. The -c option tells gcc to compile the source files into object files without linking them. The resulting object files will have the same name as their corresponding source files but with a .o extension.

ar rc liball.a *.o: This command uses the ar utility to create a static library named liball.a from all the .o object files in the current directory. The r option tells ar to replace any existing members in the archive with new members of the same name, and the c option tells it to create a new archive if one does not already exist.

ranlib liball.a: This command uses the ranlib utility to generate an index for the static library liball.a. An index is used by linkers to speed up linking with large libraries by allowing them to quickly locate symbols within the library.
